# Question 2.1
                     .__________.
position actuelle -> |contrôleur| -> commande moteur (signal binaire)
position désirée  -> |__________|

# Question 2.2

voici le squelette minimal d'un composant trouvé sur la documentation OROCOS :

#include <rtt/TaskContext.hpp>
#include <rtt/Component.hpp>
using namespace RTT;
class MyTask : public TaskContext
{
public:
  ATask(const std::string& name) : public TaskContext(name) {}
};

# Question 2.3

##Commandes bash :

#initialiser le workspace :

source /opt/ros/melodic/setup.bash
mkdir -p rosws/src
cd rosws/src
catkin_init_workspace
cd ..
catkin_make
source devel/setup.bash
source /opt/ros/melodic/setup.bash
source ~rosws/devel/setup.bash

#Créer un squelette de composant :

cd src
orocreate-catkin-pkg NomComposant component

#compiler le composant :

cd ..
catkin_make
catkin_make install
source devel/setup.bash

#charger le composant dans le deployer :

deployer-gnulinux
> import("NomComposant")
> displayComponentTypes()             pour s'assurer que le composant est bien reconnu
> loadComponent("C1", "NomComposant") pour créer une instance du composant

# Question 2.4

Lorsque l'on charge le composant sur le deployer, un fichier log se créé dans le dossier depuis lequel la commande est lancée
En créant une instance du composant Controller, on a bien le message "Controller constructed !" dans le log, ce qui signifie
que le composant a bien été construit.
Lorsque l'on quitte le deployer, le composant est détruit, son cleanupHook() est appelé et le message
"Controller cleaning up !" apparait dans le log orocos.

# Question 2.5

La création des ports et attributs du controleur s'est effectuée sans souci.

# Question 2.6

Nous avons créé un second composant : Motor. Il servira à nous assurer que notre contrôleur
envoie et récupère correctement les valeurs désirées sur ses ports.

# Question 2.7

Le déploiement s'effectue à l'aide du fichier controller.ops.
Pour exeuter le fichier controller.ops et afficher les logs orocos:
deployer-gnulinux -s controller.ops -linfo

# Question 2.8

Comme expliqué à la question 2.6, nous avons simulé le moteur en ajoutant un
second composant à notre librairie : Motor.
Ce composant possède une entrée et une sortie.

voici les connexions réalisées entre ces deux composants :
 - commande en sortie du controleur avec entrée du moteur
 - sortie du moteur avec mesure en entrée du controleur

Puisque l'objectif est de réaliser la bonne communication des composants dans le deployer,
nous n'avons pas simulé réellement le fonctionnement d'un moteur. Nous avons plutôt
proposé une version (très) simplifiée suffisante pour mettre en lumière le bon fonctionnement de
notre code : Le moteur renvoie simplement son entrée en sortie.
Nous avons tout de même implémenté un contrôleur PID (inutile dans ce cas), pour la beauté de la chose.

# Question 2.9

Pour que les sorties de nos deux composants soient lisibles dans ROS, nous avons modifié les types du contenu de
leurs ports en std_msgs::Float64, puis nous avons fait en sorte que les valeurs "mesure" et "commande" soient publiées
respectivement dans les topics "/controller_command" et "/controller_mesure"
